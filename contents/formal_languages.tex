\section{Formal Languages and Grammars}
\label{sec:formal-languages}
In the previous section, we have introduced the theoretical background necessary to understand the basic functioning of multigrid methods.
Since the goal of this thesis is to automate the design of these methods, we next direct our attention to the area of formal languages and grammars, which will allow us to treat this problem as a program synthesis task.
A formal language represents a fundamental concept of computer science that enables the expression of arbitrarily-complex computational systems in an unambiguous and well-defined manner.
Similar to most natural languages, a formal language is characterized by its \emph{alphabet}. 
The alphabet of a formal language is a non-empty set of symbols $\Sigma$.
Based on $\Sigma$ \emph{strings} can be created, which represent finite sequences of symbols.
For instance, the alphabet $\Sigma = \left\{a, b\right\}$ contains only the symbols $a$ and $b$, which makes both $aabbb$ and $abaab$ strings on the alphabet $\Sigma$.
The length of a string, denoted by $|\cdot|$, is equal to the number of symbols contained in it. 
A concatenation of two strings 
\begin{equation}
	\begin{split}
		v & = a_1 a_2 \cdots a_n \\
		w & = b_1 b_2 \cdots b_m
	\end{split}
\end{equation}
is achieved by appending the second string at the end of the first string which yields
\begin{equation}
	vw = a_1 a_2 \cdots a_n b_1 b_2 \cdots b_m.
\end{equation}
The length of the concatenated string is thus equal to the sum of the lengths of the individual strings, which means that
\begin{equation}
|vw| = |v| + |w|.
\end{equation}
Finally, we define the empty string $\lambda$ as
\begin{equation}
	\begin{split}
		& |\lambda| = 0 \\
		& v \lambda = \lambda v = v,
	\end{split}
\end{equation}
where $v$ is a string on an arbitrary alphabet.
Assume $\Sigma$ is an alphabet, then $\Sigma^*$ is the set of strings obtained by concatenating zero or an arbitrary number of symbols from $\Sigma$.
Consequently, $\Sigma^*$ always contains the empty string $\lambda$.
To exclude $\lambda$ from the set, we define $\Sigma^+ = \Sigma^* \setminus \lambda$.
Since the number of strings that can be created from an alphabet through concatenation is infinite, both $\Sigma^+$ and $\Sigma^*$ represent infinite sets.
For example, if we again define $\Sigma = \left\{a, b\right\}$, then
\begin{equation*}
	\Sigma^{*} = \left\{\lambda, a, b, aa, ab, ba, bb, aaa, aab, aba, \dots \right\}.
\end{equation*} 
In general, for a given alphabet the \emph{language} $L$ is defined as a subset of $\Sigma^*$
\begin{equation}
	L \subset \Sigma^*.
	\label{eq:language-basic-definition}
\end{equation}
However, in practice, we usually want to define a language $L_G$ that represents a specific subset of $\Sigma^*$.
One way to achieve this is to specify a list of rules that generate $L_G$.
These rules can be defined in the form of a \emph{grammar} $G$.
\begin{definition}[Grammar]
	\begin{equation}
		G = \left(V, T, S, P \right),
	\end{equation}
	where $V$ is a finite set of \emph{variables},
	$T$ a finite set of \emph{terminals},
	$S \in V$ is the \emph{start} variable and 
	$P$ a finite set of \emph{productions} or \emph{production rules}.
	We also assume that $V \neq \emptyset$, $T \neq \emptyset$ and $V \cap T = \emptyset$.
\end{definition}
The core of a grammar is the definition of the productions $P$, which are usually specified as a list of mappings
\begin{equation*}
	x \to y,
	\label{eq:unrestricted-production}
\end{equation*}
where $x \in \left(V \cup T\right)^+$ and $y \in \left(V \cup T\right)^*$.
Note that alternatively, the operator
\begin{equation*}
	x \bnfpo y
\end{equation*}
is also often used to denote a production.
Each production $x \to y$ can then be applied in the following way.
Given a string $u$ of the form 
\begin{equation*}
	u = vxw,
\end{equation*}
we can replace $x$ with $y$ to \emph{derive} a new string
\begin{equation}
	u' = vyw,
\end{equation}
which is usually written as $u \Rightarrow u'$.
This process can then be continued by applying a sequence of derivations chosen arbitrarily from the set of available productions $P$.
Within this sequence, each production can be applied whenever its conditions on the left-hand side of the rule are fulfilled, i.e., the respective pattern occurs anywhere within the current string.
Also, note that there is no limit on how many times a certain production can be applied.
Each string $u$ that can be derived by applying an arbitrary sequence of productions starting from $S$
\begin{equation*}
	S \Rightarrow \dots \Rightarrow u,
\end{equation*}
is then an element of the language $L_G$.
Assuming that 
\begin{equation*}
	S \overset{*}{\Rightarrow} u
\end{equation*}
represents the application of an arbitrary sequence of productions, we can define the language $L_G$ generated by a grammar $G$ as follows:
\begin{definition}[Language]\label{def:language}
	Let $G = \left\{V, T, S, P\right\}$ be a grammar, then
	\begin{equation}
		L_G = \left\{u \in T^* : S \overset{*}{\Rightarrow} u\right\}
	\end{equation}
is the language generated by $G$.
\end{definition}
Assuming $u \in L_G$ and 
\begin{equation}
	S \Rightarrow u_1 \Rightarrow u_2 \Rightarrow \dots \Rightarrow u_n \Rightarrow u
\end{equation}
is a \emph{derivation} of $u$, then the strings $S, u_1, u_2, \dots, u_n$ are called its \emph{sequential forms}.
\subsection{The Chomsky Hierarchy}
\label{sec:chomsky-hierarchy}
So far, we have not yet imposed any restrictions on the individual components of a grammar $G$.
We call such a grammar, whose productions are of the general form of Equation~\eqref{eq:unrestricted-production}, \emph{unrestricted}.
It can be shown that any language generated by an unrestricted grammar is recursively enumerable, which means that there exists a Turing machine capable of enumerating all strings contained in that language~\cite{linz2006introduction}.
As a consequence, one can prove that unrestricted grammars are equally powerful as Turing machines and hence both computational models are equivalent.
Since we are only interested in languages that can be processed by any Turing-complete system on a modern computer, there is no use in considering languages that do not fall into this category.
While Turing machines and unrestricted grammars both represent a universal model of computation, it can be useful to consider grammars that impose certain restrictions on their productions and thus simplify both the derivation as well as the manipulation of strings.
\emph{Context-sensitive} grammars (CSG) represent the first step in this direction.
\begin{definition}[Context-Sensitive Grammar]
A grammar $G = \left\{V, T, S, P\right\}$ is context-sensitive if all productions can be written as
\begin{equation}
	xAy \to xuy,
\end{equation}
where $A \in V$ and $x, y, u \in \left(V \cup T\right)^*$.
\label{def:context-sensitive-grammar}
\end{definition}
This means that a certain production $A \to u$ can only be performed in the \emph{context} of $x$ and $y$ thus leading to the term context-sensitive.
While unrestricted grammars can be described by a Turing machine, the equivalent model of computation for a CSG is the \emph{linear bounded automaton}, which can be described as a Turing machine whose tape is linearly bounded by the length of the string~\cite{linz2006introduction}.
Furthermore, by prohibiting any context at the left-hand side of a production one arrives at the class of \emph{context-free} grammars (CFG).
\begin{definition}[Context-Free Grammar]
	A grammar $G = \left\{V, T, S, P\right\}$ is context-free if all productions are of the form
	\begin{equation}
		A \to u,
	\end{equation}
	where $A \in V$ and $u \in \left(V \cup T\right)^*$.
\end{definition}
The equivalent model of computation for a CFG is the \emph{pushdown automaton}~\cite{linz2006introduction}.  
CFGs have a number of desirable properties that explain their widespread use in computer science, especially in the theory of programming languages~\cite{pierce2002types}.
For instance, each string generated by a CFG, as well as the derivation of each string, can be represented as a tree.
Moreover, it is possible to check whether an arbitrary string of length $n$ is contained in the language generated by a CFG using only $\mathcal{O}(n^3)$ steps.
Note that the class of CFGs is contained in the class of CSGs, since we can simply replace each production 
\begin{equation*}
	A \to u
\end{equation*}
of a CFG by one of the form
\begin{equation*}
	\lambda A \lambda \to \lambda u \lambda.
\end{equation*} 
Since $\lambda \in \left(V \cup T\right)^*$, the resulting grammar meets the requirements of Definition~\ref{def:context-sensitive-grammar}.
Finally, the introduction of further restrictions on the productions leads to the class of regular grammars (RGs).
\begin{definition}[Regular Grammar]
	A grammar $G = \left\{V, T, S, P\right\}$ is regular if all productions are of the form
	\begin{equation}
		\begin{split}
			A & \to xB \\
			A & \to x,
		\end{split}
	\end{equation}
in which case $G$ is said to be \emph{left-linear} or of the form
	\begin{equation}
	\begin{split}
		A & \to Bx \\
		A & \to x,
	\end{split}
	\end{equation}
in which case $G$ is said to be \emph{right-linear}. In both cases, $A, B \in V$ and $x \in T^*$.
\end{definition}
Since both $xB \in \left(V \cup T\right)^*$ and $Bx \in \left(V \cup T\right)^*$, it is obvious that each regular grammar can also be considered as a CFG.
Each language generated by an RG is a regular language and can thus be defined in the form of a regular expression. 
RGs, therefore, possess the same expressive power as \emph{finite-state machines}~\cite{linz2006introduction}.
With the definition of RGs, we have arrived at the bottom of the so-called \emph{Chomsky hierarchy} of formal grammars and languages, which is given by the following set of relations
\begin{equation}
	\mathcal{G} \subset \mathcal{G}_{CS} \subset \mathcal{G}_{CF} \subset \mathcal{G}_{R}, 
\end{equation} 
where $\mathcal{G}$ is the set of all unrestricted (type-0), $\mathcal{G}_{CS}$ the set of all context-sensitive (type-1), $\mathcal{G}_{CF}$ the set of all context-free (type-2) and $\mathcal{G}_{R}$ the set of all regular (type-3) grammars.
The same is true for the corresponding languages
\begin{equation}
	\mathcal{L} \subset \mathcal{L}_{CS} \subset \mathcal{L}_{CF} \subset \mathcal{L}_{R}. 
\end{equation}
Consequently, each level in this hierarchy corresponds to a particular class of grammars introduced in this section, where each subsequent level introduces further restrictions on the productions but, on the other hand, enables the use of faster and more efficient algorithms for manipulating the strings contained in its generated language.
After we have now introduced a class of formal languages for representing strings of symbols in a structured way, as well as those grammars able to generate them, we will next discuss how we can represent the construction and manipulation of such strings as an optimization problem, whose solution we aim to approximate using evolutionary search methods.