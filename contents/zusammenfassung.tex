Viele der grundlegendsten Naturgesetze können als partielle Differentialgleichungen (PDGs) formuliert werden. 
Das Verständnis dieser Gleichungen ist daher für viele Bereiche der modernen Wissenschaft und Technik von immenser Bedeutung. 
Da jedoch die allgemeine Lösung vieler PDGs unbekannt ist, stellt die effiziente Näherungslösung dieser Gleichungen eine der größten Herausforderungen der Menschheit dar.
Obwohl Mehrgitterverfahren eine der effektivsten Methoden zur numerischen Lösung von PDGs darstellen, ist der Entwurf eines effizienten oder zumindest funktionierenden Mehrgitterlösers in vielen Fällen ein offenes Problem.
In dieser Arbeit wird gezeigt, dass grammatikgeleitete genetische Programmierung, eine evolutionäre Programmsynthesetechnik, zur Entdeckung von Mehrgitterverfahren bisher unerreichter Struktur führen kann, welche zudem einen hohen Grad an Effizienz und Generalisierung erreichen.
Zu diesem Zweck entwickeln wir eine neuartige kontextfreie Grammatik, welche die automatisierte Generierung von Mehrgitterverfahren in einer symbolisch manipulierbaren formalen Sprache ermöglicht, auf deren Grundlage wir denselben mehrgitterbasierten Löser auf Probleme unterschiedlicher Größe anwenden können, ohne seine interne Struktur anpassen zu müssen.
Die Behandlung des automatisierten Entwurfs effizienter Mehrgitterverfahren als Programmsyntheseproblem erlaubt es uns neuartige Sequenzen von Mehrgitteroperationen zu finden, einschließlich der Kombination von verschiedenen Glättungs- und Grobgitterkorrekturschritten auf jeder Ebene der Diskretisierungshierarchie.
Um die Machbarkeit dieses Ansatzes zu beweisen, stellen wir seine Implementierung in Form des Python-Frameworks EvoStencils vor, das als Open-Source-Software frei verfügbar ist.
Diese Implementierung umfasst alle Schritte von der Darstellung der algorithmischen Sequenz eines Mehrgitterverfahrens in Form eines gerichteten azyklischen Graphen bestehend aus Python-Objekten bis hin zu seiner automatischen Generierung und Optimierung unter Verwendung der Fähigkeiten des ExaStencils-Frameworks zur Codegenerierung und der Bibliothek DEAP für die Implementierung evolutionärer Algorithmen.
Darüber hinaus beschreiben wir, wie diese Implementierung erweitert werden kann, um Mehrgittermethoden zu erhalten, die mehrere Instanzen derselben PDG effizient lösen können, wodurch eine starke Generalisierbarkeit erreicht werden kann.
Obwohl die Verallgemeinerung eines der Hauptziele bei der automatischen Generierung von Lösern ist, scheitern Methoden, die auf künstlicher Intelligenz basieren, oft daran diese zu erreichen. 
Zwar haben sich Modelle des maschinellen Lernens in einigen Fällen als vielversprechend bei der Ersetzung klassischer numerischer Löser erwiesen, doch basieren diese in der Regel auf einem neuronalen Netzwerk fester Größe und können daher nicht ohne weiteres auf andere Problemgrößen verallgemeinert werden.
Um die Evaluierung einer großen Anzahl von mehrgitterbasierten Lösern zu beschleunigen, leiten wir ein geeignetes verteiltes Parallelisierungsschema ab, das auf der Message-Passing-Schnittstelle (MPI) basiert und es EvoStencils ermöglicht, die Rechenleistung moderner Cluster und Supercomputer zu nutzen.
Um die Effektivität unseres Ansatzes zu untersuchen, betrachten wir verschiedene PDGs, darunter die indefinite Helmholtz-Gleichung, für die wir Mehrgitterverfahren erhalten, die im Vergleich zu klassischen Mehrgitterzyklen eine höhere Lösungseffizienz erreichen.
Darüber hinaus sind einige der mit unserem Ansatz entdeckten Methoden in der Lage, Konvergenz im Fall eines äußerst schlecht konditionierten Helmholtz-Problems zu erzielen, für das gleichzeitig alle bekannten Mehrgitterzyklen keinen konvergierenden Löser liefern.
Im Rahmen unserer Experimente zeigen wir auch, dass unsere Implementierung auf neueren Clustern und Supercomputern, wie SuperMUC-NG, einem der derzeit größten europäischen Hochleistungsrechner, ausgeführt werden kann.
Da unsere formale Darstellung von Mehrgitterverfahren leicht in ein für den Menschen lesbares Format übersetzt werden kann, führen wir schließlich eine empirische Analyse der algorithmischen Merkmale durch, welche unser evolutionären Programmsyntheseansatz hervorgebracht hat.